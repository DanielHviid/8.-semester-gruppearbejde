install.packages("doMC", dependencies = T)
library(doMC)
library(foreach)
library("jpeg")
library("EBImage")
library("class")
library("gmodels")
library("ggplot2")
library("caret")
library("data.table")
library("jmotif")
#library("lda")
library(foreach) #paralell for loop
library(doMC)
registerDoMC(3)  #change the 2 to your number of CPU
#load relevant functions
source('includes.R')
library(doParallel)
install.packages("doParallel", dependencies = T)
library(foreach)
library(doParallel)
# ------------------------------- Ubuntu (Desktop)  ------------------------------------------
{
ProjectLocation <- '~/Desktop/8.-semester-gruppearbejde1/MachineLearning/Aflevering_2/'
setwd(ProjectLocation)
folder <- "/media/tera/HDD/SmartSVN/trunk/2018/group"
folder <- "/media/tera/HDD/SmartSVN/trunk/preProcessed/2018/group"
}
#library("png")
library("jpeg")
library("EBImage")
library("class")
library("gmodels")
library("ggplot2")
library("caret")
library("data.table")
library("jmotif")
#library("lda")
source('functions.R')
#load relevant functions
source('includes.R')
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
finalMatrix <- foreach(i=1:150000, .combine=cbind) %dopar% {
tempMatrix = functionThatDoesSomething() #calling a function
#do other things if you want
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
tempMatrix = functionThatDoesSomething() #calling a function
#--------------------------------------------
#--------------- Opgave 2.1.1.2 a - all persons in
#--------------------------------------------
data = allPersonsInSplit(id100Large)
training = data[[1]]
trainingClasses = training[,1]
trainingData = training[,-1]
test = data[[2]]
testClasses = test[,1]
testData = test[,-1]
model <- prcomp(trainingData)
leastVariances = list(0.8,0.9,0.95,0.99)
listOfAccuracies <- matrix(,4,3)
listOfTimes <- matrix(,4,3)
listOfTimeVariation <- matrix(,4,3)
listOfNPCs <- matrix(,4,1)
timeSamples <- matrix(,10,1)
i<-1
i<-1
variance = model$sdev
variance = variance / sum(variance)
cumulativeVariance = cumsum(variance)
acceptableFactorVariances = variance[1:(length(cumulativeVariance[cumulativeVariance < leastVariances[i]])+1)]
NAcceptable = length(acceptableFactorVariances)
listOfNPCs[i] = NAcceptable
reducedTraining <- data.frame(data.matrix(trainingData) %*% data.matrix(model$rotation[,1:NAcceptable]))
reducedTest <- data.frame(data.matrix(testData) %*% data.matrix(model$rotation[,1:NAcceptable]))
cat("Number of principle components: ", NAcceptable, "\n")
kValues <- list(1,10,100)
data = allPersonsInSplit(id100Large)
training = data[[1]]
trainingClasses = training[,1]
trainingData = training[,-1]
test = data[[2]]
testClasses = test[,1]
testData = test[,-1]
model <- prcomp(trainingData)
leastVariances = list(0.8,0.9,0.95,0.99)
listOfAccuracies <- matrix(,4,3)
listOfTimes <- matrix(,4,3)
listOfTimeVariation <- matrix(,4,3)
listOfNPCs <- matrix(,4,1)
timeSamples <- matrix(,10,1)
i<-1
variance = model$sdev
variance = variance / sum(variance)
cumulativeVariance = cumsum(variance)
acceptableFactorVariances = variance[1:(length(cumulativeVariance[cumulativeVariance < leastVariances[i]])+1)]
NAcceptable = length(acceptableFactorVariances)
listOfNPCs[i] = NAcceptable
reducedTraining <- data.frame(data.matrix(trainingData) %*% data.matrix(model$rotation[,1:NAcceptable]))
reducedTest <- data.frame(data.matrix(testData) %*% data.matrix(model$rotation[,1:NAcceptable]))
cat("Number of principle components: ", NAcceptable, "\n")
kValues <- list(1,10,100)
i = 1
variance = model$sdev
data = allPersonsInSplit(id100Large)
source('loadImages.R')    # load the converted images
data = allPersonsInSplit(id100Large)
library(foreach)
library(doParallel)
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
training = data[[1]]
trainingClasses = training[,1]
trainingData = training[,-1]
test = data[[2]]
testClasses = test[,1]
testData = test[,-1]
model <- prcomp(trainingData)
leastVariances = list(0.8,0.9,0.95,0.99)
listOfAccuracies <- matrix(,4,3)
listOfTimes <- matrix(,4,3)
listOfTimeVariation <- matrix(,4,3)
listOfNPCs <- matrix(,4,1)
timeSamples <- matrix(,10,1)
i <- 1
variance = model$sdev
variance = variance / sum(variance)
cumulativeVariance = cumsum(variance)
acceptableFactorVariances = variance[1:(length(cumulativeVariance[cumulativeVariance < leastVariances[i]])+1)]
NAcceptable = length(acceptableFactorVariances)
listOfNPCs[i] = NAcceptable
reducedTraining <- data.frame(data.matrix(trainingData) %*% data.matrix(model$rotation[,1:NAcceptable]))
reducedTest <- data.frame(data.matrix(testData) %*% data.matrix(model$rotation[,1:NAcceptable]))
cat("Number of principle components: ", NAcceptable, "\n")
kValues <- list(1,10,100)
?foreach
finalMatrix <- foreach(i=1:10, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
finalMatrix <- foreach(i=1:10, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
finalMatrix
finalMatrix <- foreach(i=1:10000, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
#stop cluster
stopCluster(cl)
finalMatrix <- foreach(i=1:10000, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
finalMatrix <- foreach(i=1:10000, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
finalMatrix
finalMatrix <- foreach(i=1:100000, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
finalMatrix
finalMatrix(1)
finalMatrix[1]
finalMatrix[10]
finalMatrix[100]
finalMatrix[1000]
finalMatrix[10000]
finalMatrix[100000]
finalMatrix[1000000]
finalMatrix[100050]
finalMatrix[10005]
finalMatrix <- foreach(i=1:100000, .combine=cbind) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
finalMatrix[30700]
finalMatrix <- foreach(i=1:100000, .combine=cbind, .inorder = F) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
finalMatrix[30700]
finalMatrix[3700]
finalMatrix[3780]
finalMatrix <- foreach(i=1:100000, .inorder = F) %dopar% {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
foreach(i=1:4, j=1:10) %do%
sqrt(i+j)
finalMatrix <- for(i in 1:100000) {
print(i) #calling a function
#do other things if you want
tempMatrix <- i
tempMatrix #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
}
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
#stop cluster
stopCluster(cl)
registerDoParallel(cl)
foreach(i=1:3) %dopar% sqrt(i)
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)
foreach(i=1:3) %dopar% sqrt(i)
output <- foreach(i=1:3) %dopar% sqrt(i)
output
data = disjunctSplit(id100Large)
training = data[[1]]
trainingClasses = training[,1]
trainingData = training[,-1]
test = data[[2]]
testClasses = test[,1]
testData = test[,-1]
model <- prcomp(trainingData)
leastVariances = list(0.8,0.9,0.95,0.99)
listOfAccuracies <- matrix(,4,3)
listOfTimes <- matrix(,4,3)
listOfTimeVariation <- matrix(,4,3)
listOfNPCs <- matrix(,4,1)
timeSamples <- matrix(,10,1)
i = 1
variance = model$sdev
variance = variance / sum(variance)
cumulativeVariance = cumsum(variance)
acceptableFactorVariances = variance[1:(length(cumulativeVariance[cumulativeVariance < leastVariances[i]])+1)]
NAcceptable = length(acceptableFactorVariances)
listOfNPCs[i] = NAcceptable
reducedTraining <- data.frame(data.matrix(trainingData) %*% data.matrix(model$rotation[,1:NAcceptable]))
reducedTest <- data.frame(data.matrix(testData) %*% data.matrix(model$rotation[,1:NAcceptable]))
cat("Number of principle components: ", NAcceptable, "\n")
kValues <- list(1,10,100)
K = 1
cat("K-Vakues: ", kValues[[K]], "\n")
cat("j-Vakues: ", j, "\n")
start.time <- Sys.time()
test_pred <- knn(train = reducedTraining, test = reducedTest, cl = trainingClasses, k=kValues[K])
end.time <- Sys.time()
timeSamples[j] <- end.time - start.time
output <- foreach(j=1:10) %dopar% {
cat("j-Vakues: ", j, "\n")
start.time <- Sys.time()
test_pred <- knn(train = reducedTraining, test = reducedTest, cl = trainingClasses, k=kValues[K])
end.time <- Sys.time()
timeSamples[j] <- end.time - start.time
}
